// ***************************************************************
// *****      Assembly HSYNC (TIMER0) interrupt vector       *****
// ***** by Carsten Herting (slu4), last update: 17.07.2023  *****
// ***** copy 'os.h' and 'os.S' into '/Arduino/libraries/os' *****
// ***************************************************************

#define __SFR_OFFSET 0x00		// set the Special Function Register Offset from 0x20 to 0x00 in order to use AVR PORT definitions
#include <avr/io.h>			// include PORTB, DDRD, ... symbols for easier register access
#include "buffer.h"
#include "bios.h"
//.extern BIOS::charset
.extern BIOS::chardef
.extern frame_hook
.section .bss
prev: .byte 0				// PS/2 previous sample of CLK, used for edge detection		// PS/2 previous value of INSIDE
cnts: .byte 0				// PS/2 received bits counter
data: .word 0				// PS/2 datagram as it is received bit by bit
old_frame_hook:				// 16bit - func or trampoline
	.word 0
.section .text
; PORTF PF0-7 8bit data out
; PORTB PB6 D12 HSYNC
; PORTB PB7 D13 = 74HC166 Latch
; PORTE PE7 xx - 16 MHZ
; PORTE PE4 - VSYNC
; PORTE PE6  INSIDE (not Led)
; XX PINB  PB2 D10 Clock PS/2 - handled by regHandler
; XX PINB  PB1 D11 Data PS/2
; PORTH PH0-7 xxxx RGBY out
; PORTF PF0-7 xxxx PS/2 data in
; PORTB PB4 #PS2-OE active LOW

; one PS/2 character is like 15 rows, it is possible to get like 5 characters per frame - so managing it in between lines is possible and easy

.balign 64
;.global TIMER1_COMPA_vect		// define this global to make the Arduino IDE integrate the ISR
.global TIMER1_OVF_vect
.global VGA_hook
VGA_hook:	ret
.global vga_frame_hook
.type vga_frame_hook,@function
vga_frame_hook:
	// intro
				// call previous hook
	lds r30, frame_hook
	lds r31, frame_hook+1
	sbiw r30, 0	// only nonzero address
	breq 1f
	icall
1:
	// outro
	ret

.global lib_VGA_begin
lib_VGA_begin:
	lds	r24, frame_hook
	lds	r25, frame_hook+1
	sts	old_frame_hook,r24
	sts	old_frame_hook+1,r25
	
	ldi	r24, lo8(gs(vga_frame_hook))
	ldi	r25, hi8(gs(vga_frame_hook))
	sts	frame_hook,r24
	sts	frame_hook+1,r25
	
	ret
.global lib_VGA_end
lib_VGA_end:
	lds	r24, old_frame_hook
	lds	r25, old_frame_hook+1
	sts	frame_hook,r24
	sts	frame_hook+1,r25
	
	ret

// ***************************************************************

.macro ONECHAR				//     Z: address of char data (MSB is fixed, LSB depends on char), X: current VRAM position (one line)
	ld    ZL, X+			// 2CP ZL = (X), X = X + 1
	lpm   r21, Z			// 3CP get font byte from program memory for current chr on current line
	out   PORTF, r21	// 1CP put data to shift register's parallel input
;	sts PORTF,r21			// 2CP - L cannot be `out`
	
;	out   PORTB, r24	// 1CP /PE LOW (next CLK rising edge will load pixel data)
;	out   PORTB, r23	// 1CP /PE HIGH (now CLK will pump out 8 pixels)
	
	out   PINB, r24			// 1CP flip B7 LOW
	out   PINB, r24			// 1CP flip B7 HIGH
;	nop			// 1CP
 .endm
.macro check number
	cpi r20, \number
	brlo 1f
1:
.endm

// ***************************************************************

# TIMER1_COMPA_vect:			// ISR table entry is automatically generated by the AVR assembler
TIMER1_OVF_vect:
	push r1				// save r1 and r0 (r0-1 are modified by the result of a multiplication)
	push r0
	in   r0, SREG			// reads the AVR status register SREG 0x3f holding the complete flag state
	push r0				// push it on the stack, too
	
	push r20			// push content on stack, so we can use this register right away
	
;	nop
;	nop
;	nop
;	nop
	lds  r20, TCNT1			// interrupt jitter compensation using timer TCNT1 too
;	out PORTF,r20
	andi r20, 7	// also cpi r20,0
	check 7
	check 6
	check 5
	check 4
	check 3
	check 2
	check 1
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
	
;;	cbi PORTB, 4			// start HSYNC pulse by hand
	
	push  r21			// push current values of registers to be used onto stack
	push  r22
	push  r23
	push  r24
	push  r25
	push  r26			// X
	push  r27
	push  r30			// Z
	push  r31

	lds r20, vline+0		// load vline to r20-21
	lds r21, vline+1
	movw r24, r20			// copy register pair r20/21 -> r24/25
	adiw r24, 1			// increase vline by 1
	sts vline+1, r25		// and save back
	sts vline+0, r24
	lsr r21				// divide vline by 2 and subtract 30 ??? lsr also okay??
	ror r20
	subi r20, 30			// r20 = pixel line "lin"


	cpi r20, 200			// draw only 200 double-scanlines (25 x 8) (vline 60-460)
	brcs 1f				// regHandler too far for brcc
		cpi r20, 201			// ?first blank line after visible part
		brne 2f				// ?no? then skip
						// call hook
		lds r30, frame_hook
		lds r31, frame_hook+1
		sbiw r30, 0	// only nonzero address
		breq 2f
		icall
	2:
		jmp regHandler			// regHandler handles PS/2 (do not show anything out of range)
1:
;;	sbi PORTB, 4			// ??? end HSYNC (after only 1µ, should be 3,8µs but this buys valuable time here)

;	in r22, PINB			// r22 = scan PS/2 keyboard state (CLK and DAT) every 32µs
	// Note: This is not quite fast enough to cover the full PS/2 spec
	// (10.0 - 16.7kHz) but works fine with all PS/2 keyboards I have checked.
	
	mov r21, r20			// calculate VRAM row address from lin
	lsr r21
	lsr r21
	lsr r21				// lin>>3 = row number
	ldi r23, BIOS_COLS
	mul r23, r21			// ATTENTION: calculate * 40 => RESULT is in r0-r1!!!
	movw r30, r0			// RESULT r0-1 to r30-31 (Z): index of VRAM row

	ldi r24, 0			// needed for add with carry (see below)
	ldi XL, lo8(cram)		// output the row color to pins (H0-7)
	ldi XH, hi8(cram)
	add XL, r21			// add row number index to start address
	adc XH, r24			// takes a potential carry flag into account
	ld r21, X 			// load row color from (X)
;; now we have full port
;;	lsl r21				// shift color info 2 steps up to H2..5
;;	lsl r21
;;	ori r21, 3			// make sure the 20k-pull-ups stay always on for PS/2 CLK and DAT
;;	out PORTH, r21			// output color information
	sts PORTH,r21

	ldi XL, lo8(vram)
	ldi XH, hi8(vram)
	add XH, ZH			// add VRAM row index to VRAM start address
	add XL, ZL			// r26-27 = X = VRAM row address
	adc XH, r24			// takes a potential carry flag into account
	
	mov r21, r20			// get lin a 2nd time
	andi r21, 7			// only use lowest 3 bits of lin to determin charset line

	lds ZH, chardef+1		// load address of pointer 'chardef' to Z
;	ldi ZL, lo8(chardef)
;	ld ZH, Z		// load its high byte to Z. low byte is zero, becasuse charset MUST be 256 aligned
;	ldi ZH, hi8(charset)		// charset must be aligned to 256 bytes
	add ZH, r21			// now ZH points to the charset line

;	in r23, PORTB			// prepare the two different /PE states for ultra-fast switching
;	mov r24, r23			// r23: B7=1
;	ori r23, 0x80
;	andi r24, 0x7F			// r24: B7=0
	
	ldi r24, 0x80			// mask for B7 pin (Latch)
;	in r23, PORTB			//
;	or r23, r24			// set it high
;	out PORTB, r23			//
;	ldi r24, 0x80
	sbis PORTB, 7			// skip next instruction if bit is Set (2 CP) / execute it otherwise (1 CP)
	out PINB, r24			// 1 CP Flip the bit
					// now the bit is up

drawPixels:
;	ldi r20, 1 ;10			// shifts screen left BUT BE CAREFUL: if routine takes too long, it won't fit into a scanline!
;wait:	dec r20
;	brne wait
	
	ONECHAR			// transmit 40 characters at a rate of 2MHz (16MHz pixel clock)
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	ONECHAR
	
;	ONECHAR
;	ONECHAR
	
regHandler:				// regHandler handles PS/2                                                 ;
				// all is nice, but at least 8 cycles we need to keep fore- and back-ground colors ;
				// as bits are still clocked out by 74HC166
	clr r21
	ser r27				// 0xFF
	
	in r22,PINE			// read INSIDE - PE6
	andi r22, 0x40			// isolate the bit, set zero
	brne regEndSave			// if we are INSIDE, data are still incoming, just save state
	lds r23, prev			// we are not INSIDE, is it the first time?
	sbrs r23, 6			// ? if we were INSIDE last time, skip next instruction
	rjmp regEnd			// no, we was not INSIDE, so just finish (nothing new)
	// now we have data, get it
	sts PORTF,r21			// clear Data
	sts DDRF, r21			// enable input from PORTF
	cbi PORTE,2			// enable output from PS/2
	
	ldi ZH, hi8(BIOS_buffer)	// prepare Z for an indirect store                                         ;
	ldi ZL, lo8(BIOS_buffer)                                                                                   ;
	lds r24, BIOS_buffer_head_ptr	// load direct from data space: "BIOS_buffer_head_ptr" index               ;
	add ZL, r24                                                                                                ;
	adc ZH, r21                                                                                                ;
	                                                                                                           ;
	lds r25,PINF			// get PS/2 data into r25
	
	sbi PORTE,2			// disable output from PS/2
	sts DDRF, r27			// set PORTF for output again
	sts PORTF, r21
                                                                                                                   ;
	st Z, r25			// store scan code -> (Z)                                                  ;

	inc r24				// BIOS_buffer_head_ptr++                                                  ;
	andi r24, BUFFER_MASK		// only use 16 bytes for KEYBUFSIZE (wrap around)                          ;
	lds r26, BIOS_buffer_tail_ptr	// check if full                                                           ;
	cpse r24, r26                   // compare skip next if equel                                              ;
	sts BIOS_buffer_head_ptr, r24	// store BIOS_buffer_head_ptr back to data space                           ;
        
; }}}                                                                                                                   ;
regEndSave:                                                                                                            ;
	sts prev, r22			// remember the state of CLK                                               ;
regEnd:                                                                                                            ;
	sts PORTF, r21
	pop r31				// restore previous values of used registers                               ;
	pop r30				// Z                                                                       ;
	pop r27                                                                                                    ;
	pop r26				// X                                                                       ;
	pop r25                                                                                                    ;
	pop r24                                                                                                    ;
	pop r23                                                                                                    ;
	pop r22                                                                                                    ;
	pop r21                                                                                                    ;
	pop r20                                                                                                    ;
	pop r0				// restore the AVR status register SREG 0x3f value                         ;
	out SREG, r0			// set the SREG back to what it was                                        ;
	pop r0				// restore r0, r1                                                          ;
	pop r1                                                                                                     ;
	reti				// return from interrupt                                                   ;
/*                                                                                                                 
	-----------                                                                                                
	MIT License                                                                                                
	-----------                                                                                                
	Copyright (c) 2023 Carsten Herting                                                                         
	Permission is hereby granted, free of charge, to any person obtaining a copy of                            
	this software and associated documentation files (the "Software"), to deal in                              
	the Software without restriction, including without limitation the rights to                               
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies                              
	of the Software, and to permit persons to whom the Software is furnished to do                             
	so, subject to the following conditions:                                                                   
	The above copyright notice and this permission notice shall be included in all                             
	copies or substantial portions of the Software.                                                            
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/
