; .. vim: ft=asm showbreak=--Â»\  noexpandtab fileencoding=utf-8 nomodified   wrap textwidth=0 foldmethod=marker foldmarker={{{,}}} foldcolumn=4 ruler showcmd lcs=tab\:|- list tabstop=8 noexpandtab nosmarttab softtabstop=0 shiftwidth=0 linebreak  


DEFWORD w_ACCEPT,		0,		"ACCEPT",		f_docol, yes	; ( c-addr max -- n ) (  --  ) move INPUT to addr, limited to max chars, return actual number TODO [0695]
; {{{

	P24 var_TCB_AIB_max_cw
	P24 w_word_store_cw
	P24 w_AIB_CLEAR_cw
	P24 var_PROMPT_X_cw
	P24 var_PROMPT_Y_cw
	P24 w_CURSOR_XY_cw
;	P24 w_BEGIN_cw
2:
	P24 w_KEY_cw
	P24 w_qDUP_cw
;	P24 w_IF_cw	; 3: key
	P24 w_0BRANCH_cw
	P24 3f - .
;	P24 w_CASE_cw	; 4: ENDCASE
	P24 const_K_ENTER_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_LEAVE_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 const_K_LEFT_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_CURSOR_LEFT_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 const_K_RIGHT_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_CURSOR_RIGHT_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 const_K_BACKSPACE_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_AIB_BACKSPACE_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 const_K_DEL_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_AIB_DELETE_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 const_K_ESC_cw
;	P24 w_OF_cw	; OF
	P24 w_OVER_cw
	P24 w_equals_cw
	P24 w_0BRANCH_cw
	P24 5f - .
	P24 w_DROP_cw	; ..OF
	P24 w_AIB_CLEAR_cw
;	P24 w_ENDOF_cw	; ENDOF
	P24 w_BRANCH_cw
	P24 4f - .
5:
	P24 w_DUP_cw
	P24 w_AIB_INSERT_cw
;	P24 w_ENDCASE_cw
	P24 w_DROP_cw
4:			; ENDCASE
	P24 w_DRAW_AIB_cw
;	P24 w_THEN_cw	; 3: key
3:
;	P24 w_AGAIN_cw
	P24 w_BRANCH_cw
	P24 2b -.
	P24 var_TCB_AIB_cw
	P24 w_SWAP_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 w_RAM_MOVE_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 w_exit_cw
; }}}
; : ACCEPT ( addr max -- n ) {{{
;    TCB_AIB_max !
;    AIB-CLEAR
;    PROMPT_X PROMPT_Y CURSOR_XY
; 
;    BEGIN
;       KEY ?DUP IF
;          CASE
;             K_ENTER      OF LEAVE ENDOF
;             K_LEFT       OF CURSOR-LEFT ENDOF
;             K_RIGHT      OF CURSOR-RIGHT ENDOF
;             K_BACKSPACE  OF AIB-BACKSPACE ENDOF
;             K_DEL        OF AIB-DELETE ENDOF
;             K_ESC        OF AIB-CLEAR ENDOF
;             \ default: normalni znak
;             DUP AIB-INSERT
;          ENDCASE
;          DRAW-AIB
;       THEN
;    AGAIN
; 
;    \ kopirovani do cilove adresy
;     AIB SWAP TCB_AIB_len @ RAM-MOVE
;    TCB_AIB_len @ ;
;  }}}

; https://forth-standard.org/standard/core/ACCEPT
; 
; 6.1.0695 ACCEPT CORE
; ( c-addr +n1 -- +n2 )
; 
; Receive a string of at most +n1 characters. An ambiguous condition exists if +n1 is zero or greater than 32,767. Display graphic characters as they are received. A program that depends on the presence or absence of non-graphic characters in the string has an environmental dependency. The editing functions, if any, that the system performs in order to construct the string are implementation-defined.
; 
; Input terminates when an implementation-defined line terminator is received. When input terminates, nothing is appended to the string, and the display is maintained in an implementation-defined way.
; 
; +n2 is the length of the string stored at c-addr.
; 
; See:
; A.6.1.0695 ACCEPT.
; 
; Rationale:
; Specification of a non-zero, positive integer count (+n1) for ACCEPT allows some implementors to continue their practice of using a zero or negative value as a flag to trigger special behavior. Insofar as such behavior is outside the standard, Standard Programs cannot depend upon it, but the committee doesn't wish to preclude it unnecessarily. Because actual values are almost always small integers, no functionality is impaired by this restriction.
; 
; It is recommended that all non-graphic characters be reserved for editing or control functions and not be stored in the input string.
; 
; Because external system hardware and software may perform the ACCEPT function, when a line terminator is received the action of the cursor, and therefore the display, is implementation-defined. It is recommended that the cursor remain immediately following the entered text after a line terminator is received. 
; 

DEFWORD w_BEEP,			0,		"BEEP",			f_docol, yes	; ( -- ) BEEP
	P24 w_LIT1_cw
	.byte '\b'
	P24 w_EMIT_cw
	P24 w_exit_cw

; PrÃ¡ce s kurzorem

DEFWORD w_PLACE_CURSOR,		0,		"PLACE_CURSOR",		f_docol, yes	; ( -- ) set cursor pos

	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 var_PROMPT_X_cw
	P24 w_plus_cw
	P24 var_PROMPT_Y_cw
	P24 w_CURSOR_XY_cw
	P24 w_exit_cw
; {{{
;   TCB_AIB_cur @ PROMPT_X + PROMPT_Y 
;   CURSOR_XY ;
; }}}


; PÅ™ekreslenÃ­ Å™Ã¡dku

DEFWORD w_DRAW_AIB,		0,		"DRAW_AIB",		f_docol, yes	; ( -- ) draw current data
; {{{
	P24 var_PROMPT_X_cw
	P24 var_PROMPT_Y_cw
	P24 w_CURSOR_XY_cw

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 w_zero_cw
;	P24 w_?DO_cw	; 2
	P24 w_2toR_cw
2:

	P24 w_DUP_cw
	P24 w_I_cw
	P24 w_plus_cw
	P24 w_char_at_cw
	P24 w_EMIT_cw

	P24 w_LOOP_cw
	P24 2b - .

	P24 w_DROP_cw

	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_max_cw
	P24 w_word_at_cw
;	P24 w_?DO_cw	; 2
	P24 w_2toR_cw
2:

	P24 const_BL_cw
	P24 w_EMIT_cw

	P24 w_LOOP_cw
	P24 2b - .

	P24 w_PLACE_CURSOR_cw
	P24 w_exit_cw
; }}}
; {{{  : DRAW-AIB ( -- )
;    PROMPT_X PROMPT_Y CURSOR_XY
;    AIB TCB_AIB_len @ 0 ?DO
;       DUP I + C@ EMIT
;    LOOP
;    DROP
;    \ vymazat zbytek po konci (pokud se mazalo)
;    TCB_AIB_len @ TCB_AIB_max @ ?DO
;       BL EMIT
;    LOOP
;    PLACE-CURSOR ;
; }}}

; VklÃ¡dÃ¡nÃ­ znaku

DEFWORD w_AIB_INSERT,		0,		"AIB_INSERT",		f_docol, yes	; ( c -- ) insert char
; {{{

	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_max_cw
	P24 w_word_at_cw
	P24 w_equals_cw
;	P24 w_IF_cw	; 2
	P24 w_0BRANCH_cw
	P24 2f - .

	P24 w_DROP_cw
	P24 w_BEEP_cw
	P24 w_EXIT_cw

;	P24 w_THEN_cw
2:

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_plus_cw

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_plus_cw
	P24 w_one_plus_cw

	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_minus_cw

	P24 w_RAM_MOVE_cw

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_plus_cw
	P24 w_char_store_cw

	P24 w_one_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_plus_word_store_cw

	P24 w_one_cw
	P24 var_TCB_AIB_len_cw
	P24 w_plus_word_store_cw
	P24 w_exit_cw
 ; }}}
; {{{ : AIB-INSERT ( c -- )
;    TCB_AIB_len W@ TCB_AIB_max W@ = IF
;       DROP BEEP EXIT
;    THEN
;    \ posun doprava
;    TCB_AIB TCB_AIB_cur W@ +        \ src
;    TCB_AIB TCB_AIB_cur W@ + 1+     \ dst
;    TCB_AIB_len W@ TCB_AIB_cur W@ -  \ count
;    RAM-MOVE
;    \ vloz znak
;    TCB_AIB TCB_AIB_cur W@ + C!
;    1 TCB_AIB_cur +W!
;    1 TCB_AIB_len +W! ;
; }}}

; Backspace

DEFWORD w_AIB_BACKSPACE,	0,		"AIB_BACKSPACE",	f_docol, yes	; (  -- ) backspace

	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_zero_equals_cw
;	P24 w_IF_cw	; 2
	P24 w_0BRANCH_cw
	P24 2f - .

	P24 w_BEEP_cw
	P24 w_EXIT_cw

;	P24 w_THEN_cw
2:

	P24 w_one_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_minus_word_store_cw

	P24 w_AIB_DELETE_cw
	P24 w_exit_cw

; {{{ : AIB-BACKSPACE ( -- )
;    TCB_AIB_cur W@ 0= IF
;       BEEP EXIT
;    THEN
;    1 TCB_AIB_cur -W!
;    AIB-DELETE ;
; }}}
; Delete

DEFWORD w_AIB_DELETE,		0,		"AIB_DELETE",		f_docol, yes	; (  -- ) delete char

	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 w_equals_cw
;	P24 w_IF_cw	; 2
	P24 w_0BRANCH_cw
	P24 2f - .

	P24 w_BEEP_cw
	P24 w_EXIT_cw

;	P24 w_THEN_cw
2:

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_plus_cw
	P24 w_one_plus_cw

	P24 var_TCB_AIB_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_plus_cw

	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_minus_cw
	P24 w_one_minus_cw

	P24 w_RAM_MOVE_cw

	P24 w_one_cw
	P24 var_TCB_AIB_len_cw
	P24 w_minus_word_store_cw
	P24 w_exit_cw

; {{{ : AIB-DELETE ( -- )
;    TCB_AIB_cur W@ TCB_AIB_len W@ = IF
;       BEEP EXIT
;    THEN
;    TCB_AIB TCB_AIB_cur W@ + 1+     \ src
;    TCB_AIB TCB_AIB_cur W@ +        \ dst
;    TCB_AIB_len W@ TCB_AIB_cur W@ - 1-  \ count
;    RAM-MOVE
;    1 TCB_AIB_len -W! ;
; }}}
; Pohyb kurzoru

DEFWORD w_CURSOR_LEFT,		0,		"CURSOR_LEFT",		f_docol, yes	; ( -- ) 


	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 w_zero_equals_cw
;	P24 w_IF_cw		; 2
	P24 w_0BRANCH_cw
	P24 2f - .

	P24 w_BEEP_cw
;	P24 w_ELSE_cw
	P24 w_BRANCH_cw
	P24 3f - .
2:
	P24 w_one_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_minus_word_store_cw
;	P24 w_THEN_cw
3:
	P24 w_exit_cw

; {{{ : CURSOR-LEFT ( -- )
;   TCB_AIB_cur W@ 0= IF BEEP ELSE 1 TCB_AIB_cur -W! THEN ;
; }}}

DEFWORD w_CURSOR_RIGHT,		0,		"CURSOR_RIGHT",		f_docol, yes	; ( -- ) 

	P24 var_TCB_AIB_cur_cw
	P24 w_word_at_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_at_cw
	P24 w_equals_cw
;	P24 w_IF_cw
	P24 w_0BRANCH_cw
	P24 2f - .

	P24 w_BEEP_cw
;	P24 w_ELSE_cw
	P24 w_BRANCH_cw
	P24 3f - .
2:
	P24 w_one_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_plus_word_store_cw
;	P24 w_THEN_cw
3:
	P24 w_exit_cw
; {{{ : CURSOR-RIGHT ( -- )
;   TCB_AIB_cur W@ TCB_AIB_len W@ = IF BEEP ELSE 1 TCB_AIB_cur +W! THEN ;
; }}}

; Escape (vymazat vÅ¡e)

DEFWORD w_AIB_CLEAR,		0,		"AIB_CLEAR",		f_docol, yes	; ( c -- ) insert char

	P24 w_zero_cw
	P24 var_TCB_AIB_len_cw
	P24 w_word_store_cw

	P24 w_zero_cw
	P24 var_TCB_AIB_cur_cw
	P24 w_word_store_cw
	P24 w_exit_cw

; {{{ : AIB-CLEAR ( -- )
;    0 TCB_AIB_len W!
;    0 TCB_AIB_cur W! ;
; }}}

/*
:date: 2026.01.24 01:18:19
:_modified: 1970.01.01 00:00:00
:tags: FORTH,AI
:authors: Gilhad
:summary: ACCEPT_kecy
:title: ACCEPT_kecy
:nice_title: |logo| %title% |logo|

%HEADER%

ACCEPT_kecy
--------------------------------------------------------------------------------


You said:
Chtel bych do FORTHu napsat slovo ACCEPT (address max -- number), ktere
- dostane adresu a maximalni pocet znaku, ty nacte pomoci slova KEY s jednoduchou editaci az do delky toho zadaneho max a pak je presune na zadanou adresu a na zasobniku vrati, kolik jich presunulo
- editace bude pouzivat klavesy DEL, BACKSPACE, sipky vpravo a vlevo, ESC smaze vse dosud nactene, ENTER to naopak odesle, ostatni znaky se vkladaji na misto kurzoru. Pokud zadavane znaky presahnou hodnotu max, znak se bude ignorovart a zavola se slovo BEEP
- bude cist klavesy vstupujici prez KEY ( -- c ) ktere vraci bud nulu (pokud neni zatim dostupny znak), nebo znak 
- bude pouzivat buffer AIB (Accept Input Buffer) o delce TCB_AIB_max znaku (ktery je zarucene minimalne tak velky jako pozadovany max)
- bude zobrazovat zatim  zadane znaky pomoci slov CURSOR_XY (x y -- ) (presune kurzor na dane souradnice) a EMIT (c -- ) zobrazi znak a posune kurzor
- zobrazovani zacina na souradnicich danymi konstantami PROMPT_X PROMPT_Y a pokracuje od toho mista doprava. 
- nejspis bude potreba dalsich pomocnych slov, ktera je potreba taky navrhnout
Je takoveto zadani dostatecne, nebo potrebuje jeste neco upresnit?
ChatGPT said:

KrÃ¡tkÃ¡ odpovÄ›Ä: zadÃ¡nÃ­ je hodnÄ› dobrÃ© a implementovatelnÃ©, ale pÃ¡r drobnostÃ­ by stÃ¡lo za to upÅ™esnit, jinak se ÄlovÄ›k pÅ™i psanÃ­ ACCEPTu bude muset domÃ½Å¡let detaily (a v FORTHu to Äasto znamenÃ¡ rozdÃ­lnÃ© chovÃ¡nÃ­).

PÅ¯jdu bod po bodu a Å™eknu, co je jasnÃ© a kde jsou mezery.
Co je uÅ¾ teÄ jasnÃ© ğŸ‘

Tohle je specifikovanÃ© velmi sluÅ¡nÄ›:

    Stack efekt:
    ACCEPT ( addr max -- n ) â€“ jasnÃ©, klasickÃ©.

    Zdroj vstupu:
    KEY ( -- c ), vracÃ­ 0 pokud nic nenÃ­ â†’ implicitnÄ› polling.

    Editace:

        DEL, BACKSPACE

        â† â†’

        ESC = smaÅ¾e celÃ½ Å™Ã¡dek

        ENTER = potvrzenÃ­

        vklÃ¡dÃ¡nÃ­ na pozici kurzoru

    Limit dÃ©lky:

        pÅ™i pÅ™ekroÄenÃ­ max znak ignorovat + BEEP

    InternÃ­ buffer:

        AIB, dÃ©lka TCB_AIB_max

        garantovÃ¡no TCB_AIB_max >= max

    ZobrazenÃ­:

        vÃ½stup pÅ™es CURSOR_XY a EMIT

        zaÄÃ¡tek na (PROMPT_X, PROMPT_Y)

        vykreslovÃ¡nÃ­ doprava

Tohle vÅ¡echno je z pohledu nÃ¡vrhu ACCEPTu zcela dostateÄnÃ©.
Co bych jeÅ¡tÄ› upÅ™esnil (jinak budou â€implementaÄnÃ­ domnÄ›nkyâ€œ) âš ï¸
1ï¸âƒ£ PÅ™esnÃ© kÃ³dy klÃ¡ves

Tohle je nejvÄ›tÅ¡Ã­ dÃ­ra.

    JakÃ© hodnoty vracÃ­ KEY pro:

        BACKSPACE

        DEL

        ESC

        ENTER

        â† â†’

NapÅ™.:

    BACKSPACE = 8?

    DEL = 127?

    ENTER = 13, 10, nebo obojÃ­?

    Å ipky = ANSI sekvence (ESC [ D, ESC [ C), nebo uÅ¾ zjednoduÅ¡enÃ© kÃ³dy?

Bez toho:

    buÄ musÃ­ ACCEPT parsovat escape sekvence

    nebo pÅ™edpoklÃ¡dat â€magickÃ© konstantyâ€œ

ğŸ‘‰ DoporuÄenÃ­:
BuÄ:

    pÅ™esnÄ› vypsat kÃ³dy
    nebo

    Å™Ã­ct â€KEY uÅ¾ vracÃ­ normalizovanÃ© kÃ³dy (napÅ™. K_LEFT, K_RIGHTâ€¦)â€œ

2ï¸âƒ£ ChovÃ¡nÃ­ kurzoru na krajÃ­ch Å™Ã¡dku

Co se mÃ¡ stÃ¡t kdyÅ¾:

    kurzor je na zaÄÃ¡tku a:

        BACKSPACE?

        â† ?

    kurzor je na konci a:

        â†’ ?

    DEL na poslednÃ­m znaku?

Ignorovat? BEEP? Nic?

Tohle je drobnost, ale bez rozhodnutÃ­ vznikne chaos.
3ï¸âƒ£ ZpÅ¯sob pÅ™ekreslovÃ¡nÃ­ Å™Ã¡dku

DvÄ› moÅ¾nosti:

    plnÃ© pÅ™ekreslenÃ­ celÃ© AIB pÅ™i kaÅ¾dÃ© zmÄ›nÄ›

    inkrementÃ¡lnÃ­ (posouvÃ¡nÃ­ znakÅ¯, mazÃ¡nÃ­, dopisovÃ¡nÃ­)

NenÃ­ nutnÃ© to pÅ™ikazovat, ale je dobrÃ© Å™Ã­ct:

    â€ACCEPT je zodpovÄ›dnÃ½ za konzistentnÃ­ zobrazenÃ­ Å™Ã¡dkuâ€œ

Jinak nenÃ­ jasnÃ©, zda napÅ™. po DELETE mÃ¡:

    ruÄnÄ› smazat znak na obrazovce

    nebo pÅ™ekreslit celÃ½ Å™Ã¡dek

4ï¸âƒ£ Po ENTER â€“ co se stane s kurzorem?

NapÅ™.:

    zÅ¯stane na konci Å™Ã¡dku?

    skoÄÃ­ na novÃ½ Å™Ã¡dek?

    ACCEPT kurzor vÅ¯bec neÅ™eÅ¡Ã­ dÃ¡l?

Tohle je maliÄkost, ale v REPLu dost viditelnÃ¡.
5ï¸âƒ£ KopÃ­rovÃ¡nÃ­ z AIB do cÃ­lovÃ© adresy

Je jasnÃ©, Å¾e:

    po ENTER se:

        n znakÅ¯ z AIB pÅ™esune na addr

        vrÃ¡tÃ­ se n

Ale:

    kopÃ­rujÃ­ se znaky pÅ™esnÄ› v poÅ™adÃ­ v bufferu? (asi ano)

    bez nulovÃ©ho terminÃ¡toru? (asi ano, FORTH-style)

StaÄÃ­ jednou vÄ›tou potvrdit.
ShrnutÃ­

ğŸ‘‰ Ano, zadÃ¡nÃ­ je v zÃ¡sadÄ› dostateÄnÃ© a dÃ¡vÃ¡ smysl.
ğŸ‘‰ Na implementaci ACCEPTu vÄetnÄ› editace ÃºplnÄ› staÄÃ­.

Ale pokud to mÃ¡ bÃ½t:

    Å¡kolnÃ­ Ãºloha

    referenÄnÃ­ implementace

    nebo zÃ¡klad pro dalÅ¡Ã­ systÃ©m

pak bych doporuÄil doplnit hlavnÄ›:

    kÃ³dy klÃ¡ves (nebo jejich abstrakci)

    chovÃ¡nÃ­ na krajÃ­ch Å™Ã¡dku

    co pÅ™esnÄ› dÄ›lat s kurzorem po ENTER

ChceÅ¡-li, mÅ¯Å¾u:

    navrhnout konkrÃ©tnÃ­ pomocnÃ¡ slova (MOVE-CURSOR, INSERT-CHAR, DELETE-CHARâ€¦)

    nebo rovnou navrhnout strukturu AIB a stavovÃ©ho stroje ACCEPTu

    nebo napsat kostru kÃ³du ve FORTHu (ÄistÄ› logiku, bez vazby na HW)

StaÄÃ­ Å™Ã­ct, kam chceÅ¡ jÃ­t dÃ¡l 


You said:

- sipky uz budou zjednodusene kody, ENTER bude jen jeden znak, 
- KEY vraci uz normalizovane kody K_DEL, K_ENTER, K_LEFT a podobne, definovane nekde drive (dopisu je az pozdeji, spolu s ostatnim)
- kurzor na zacatku a K_BACKSPACE nebo K_LEFT znamena zavolat BEEP a ignorovat pohyb/akci, stejne tak K_RIGHT a K_DEL na konci radku
- ACCEPT je zodpovedny za prekreslovani radku, je jedno, zda ho po kazde zmene prekresly cely, nebo jen nezbytnou cast, ale musi nakonec umistit kurzor na spravne misto pomoci CURSOR_XY (na misto, kam se vlozi dalsi normalni znak) Na konci radku (max) bud zustane na poslednim znaku, nebo o jedno pole za nim
Po ENTER se ACCEPT o kurzor ani o radek uz nemusi starat, na zacatku ACCEPT zacina s prazdnym radkem/bufferem (cili jen da kurzor na prvni pole)
Znaky se kopiruji v poradi v bufferu, bez nuloveho terminatoru (FORTH-style), adresu zna volajici, pocet dostane na zasobniku

Jde o rozsireni mojeho hobby projektu, kdy pisu FORTH pro atmega2560, uz mam vyresene jednotne ukazatele pro RAM i FLESH (a vyhledove i externi uloziste), jednoduche cteni znaku a jejich odesilani (prez Serial) taky chodi, FORTH uz umi radu primitiv a pridavam dalsi (zaklad slovniku je ve FLESH, pridavani slov je do RAM ale diky jednotnym 24bit ukazatelum je celkem jedno co kde je (pokud se nepise do FLASH, samozrejme)), CELL jsou 3 byty (24bitu), takze se do nich vejde ukazatel kamkoli a pro bezne vypocty to staci s rezevou. FORTH mi spravne interpretuje slova jak ve FLASH, tak i v RAM, ale ted potrebuju mit moznost s nim interagovat. Tedy ten ACCEPT, ktery bude davat data pro WORD.

Takze potrebuju slovo ACCEPT, pripadne vsechna dalsi slova, ktera bude pouzivat, pokud mozno ve FORTHu, ale klidne muzu pridat i primitiva na cokoli bude potreba.



ChatGPT said:

Tohle uÅ¾ je velmi dobÅ™e doÄiÅ¡tÄ›nÃ© zadÃ¡nÃ­ 
V tÃ©hle podobÄ› je ACCEPT jednoznaÄnÄ› definovatelnÃ½ a hlavnÄ› rozumnÄ› implementovatelnÃ½ i ÄistÄ› ve FORTHu, s minimem (nebo nulou) novÃ½ch primitiv.

NÃ­Å¾e ti:

    potvrdÃ­m, Å¾e je zadÃ¡nÃ­ kompletnÃ­

    navrhnu vnitÅ™nÃ­ model ACCEPTu (stav, promÄ›nnÃ©)

    navrhnu sadu pomocnÃ½ch slov

    naznaÄÃ­m Å™Ã­dicÃ­ smyÄku ACCEPTu (FORTH-style pseudokÃ³d)

1ï¸âƒ£ ZadÃ¡nÃ­ â€“ verdikt

ğŸ‘‰ Ano, teÄ uÅ¾ je zadÃ¡nÃ­ dostateÄnÃ©.
Dokonce bych Å™ekl â€uÄebnicovÄ› ÄistÃ©â€œ.

MÃ¡Å¡:

    normalizovanÃ© klÃ¡vesy

    jasnÃ© chovÃ¡nÃ­ na hranÃ¡ch

    jasnou odpovÄ›dnost za vykreslovÃ¡nÃ­

    jasnÃ½ Å¾ivotnÃ­ cyklus kurzoru

    jasnÃ½ kontrakt vÅ¯Äi WORD

Tohle je pÅ™esnÄ› ten level, kdy se dÃ¡ ACCEPT napsat bez improvizace.
2ï¸âƒ£ VnitÅ™nÃ­ model ACCEPTu

DoporuÄenÃ½ minimÃ¡lnÃ­ stav (v RAM):

AIB        \ adresa bufferu
TCB_AIB_len    \ aktuÃ¡lnÃ­ dÃ©lka textu (0 .. max)
TCB_AIB_cur    \ pozice kurzoru (0 .. TCB_AIB_len)
TCB_AIB_max    \ maximÃ¡lnÃ­ povolenÃ¡ dÃ©lka (parametr ACCEPTu)

Invarianta:

0 <= TCB_AIB_cur <= TCB_AIB_len <= TCB_AIB_max

Kurzor na obrazovce:

x = PROMPT_X + TCB_AIB_cur
y = PROMPT_Y

3ï¸âƒ£ PomocnÃ¡ slova (nÃ¡vrh API)
ğŸ”¹ PrÃ¡ce s kurzorem


: PLACE-CURSOR ( -- )
   TCB_AIB_cur @ PROMPT_X + PROMPT_Y 
   CURSOR_XY ;

ğŸ”¹ PÅ™ekreslenÃ­ Å™Ã¡dku

DoporuÄuju jednoduchÃ© plnÃ© pÅ™ekreslenÃ­ â€“ je to ÄitelnÃ© a na ATmeze to bohatÄ› staÄÃ­.

: DRAW-AIB ( -- )
   PROMPT_X PROMPT_Y CURSOR_XY
   AIB TCB_AIB_len @ 0 ?DO
      DUP I + C@ EMIT
   LOOP
   DROP
   \ vymazat zbytek po konci (pokud se mazalo)
   TCB_AIB_len @ TCB_AIB_max @ ?DO
      BL EMIT
   LOOP
   PLACE-CURSOR ;

ğŸ”¹ VklÃ¡dÃ¡nÃ­ znaku

: AIB-INSERT ( c -- )
   TCB_AIB_len @ TCB_AIB_max @ = IF
      DROP BEEP EXIT
   THEN
   \ posun doprava
   AIB TCB_AIB_cur @ +        \ dst
   AIB TCB_AIB_cur @ + 1+     \ src
   TCB_AIB_len @ TCB_AIB_cur @ -  \ count
   MOVE
   \ vloz znak
   AIB TCB_AIB_cur @ + C!
   1 TCB_AIB_cur +!
   1 TCB_AIB_len +! ;

ğŸ”¹ Backspace

: AIB-BACKSPACE ( -- )
   TCB_AIB_cur @ 0= IF
      BEEP EXIT
   THEN
   -1 TCB_AIB_cur +!
   AIB-DELETE ;

ğŸ”¹ Delete

: AIB-DELETE ( -- )
   TCB_AIB_cur @ TCB_AIB_len @ = IF
      BEEP EXIT
   THEN
   AIB TCB_AIB_cur @ + 1+     \ src
   AIB TCB_AIB_cur @ +        \ dst
   TCB_AIB_len @ TCB_AIB_cur @ - 1-  \ count
   MOVE
   -1 TCB_AIB_len +! ;

ğŸ”¹ Pohyb kurzoru

: CURSOR-LEFT ( -- )
   TCB_AIB_cur @ 0= IF BEEP ELSE -1 TCB_AIB_cur +! THEN ;

: CURSOR-RIGHT ( -- )
   TCB_AIB_cur @ TCB_AIB_len @ = IF BEEP ELSE 1 TCB_AIB_cur +! THEN ;

ğŸ”¹ Escape (vymazat vÅ¡e)

: AIB-CLEAR ( -- )
   0 TCB_AIB_len !
   0 TCB_AIB_cur ! ;

4ï¸âƒ£ Å˜Ã­dicÃ­ smyÄka ACCEPTu

PÅ™ehlednÄ›, bez magie:

: ACCEPT ( addr max -- n )
   TCB_AIB_max !
   AIB-CLEAR
   PROMPT_X PROMPT_Y CURSOR_XY

   BEGIN
      KEY ?DUP IF
         CASE
            K_ENTER      OF LEAVE ENDOF
            K_LEFT       OF CURSOR-LEFT ENDOF
            K_RIGHT      OF CURSOR-RIGHT ENDOF
            K_BACKSPACE  OF AIB-BACKSPACE ENDOF
            K_DEL        OF AIB-DELETE ENDOF
            K_ESC        OF AIB-CLEAR ENDOF
            \ default: normalni znak
            DUP AIB-INSERT
         ENDCASE
         DRAW-AIB
      THEN
   AGAIN

   \ kopirovani do cilove adresy
   DUP                 \ addr
    AIB TCB_AIB_len @ MOVE
    DROP
   TCB_AIB_len @ ;

(Detaily stacku si doladÃ­Å¡ podle svÃ© konvence, ber to jako strukturu.)
5ï¸âƒ£ PoznÃ¡mka k ATmega2560 & 24bit CELL

UpÅ™Ã­mnÄ›:
ğŸ‘‰ CELL = 3 bajty je krÃ¡snÃ© Å™eÅ¡enÃ­
a jednotnÃ© ukazatele RAM/FLASH jsou pÅ™esnÄ› to, co klasickÃ½ FORTH nikdy poÅ™Ã¡dnÄ› nevyÅ™eÅ¡il.

U ACCEPTu to mÃ¡Å¡ vÃ½hodu:

    AIB je v RAM

    MOVE / C@ / C! pracujÃ­ nad jednotnÃ½m adresnÃ­m prostorem

    WORD uÅ¾ jen Å¾ere data

Nic z toho tÄ› nelimituje.
ZÃ¡vÄ›r

    âœ… ZadÃ¡nÃ­ je teÄ kompletnÃ­

    âœ… ACCEPT jde napsat pÅ™evÃ¡Å¾nÄ› ve FORTHu

    âš ï¸ JedinÃ© primitivum navÃ­c, kterÃ© se fakt hodÃ­: MOVE (pokud ho jeÅ¡tÄ› nemÃ¡Å¡)

Jestli chceÅ¡:

    mÅ¯Å¾eme to zkonkretizovat do skuteÄnÃ©ho kÃ³du pro tvÅ¯j FORTH

    nebo se podÃ­vat rovnou na WORD, aÅ¥ ACCEPT a WORD do sebe zapadnou bez lepidla

    pÅ™Ã­padnÄ› optimalizovat redraw (inkrementÃ¡lnÃ­ update)

Tenhle projekt znÃ­ fakt pÄ›knÄ› nerdovsky ğŸ’™


*/
