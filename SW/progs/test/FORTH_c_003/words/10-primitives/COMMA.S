; .. vim: ft=asm showbreak=--Â»\  noexpandtab fileencoding=utf-8 nomodified   wrap textwidth=0 foldmethod=marker foldmarker={{{,}}} foldcolumn=4 ruler showcmd lcs=tab\:|- list tabstop=8 noexpandtab nosmarttab softtabstop=0 shiftwidth=0 linebreak  

DEFWORD w_comma,		0,		",",			f_comma			; ( x --  ) compile x at HERE
DEFWORD w_COMPILEcomma,		0,		"COMPILE,",		f_comma			; ( x --  ) compile x at HERE

.section CURRENT_TEXT_SECTION,"ax",@progbits
gfunc f_comma	; {{{ #
	TCB_member	TCB_HERE
			RB3at
		Set3	Zx, Parsx
		Set3	Parsx, TOS
			RW3at
		Set3	Parsx, Zx
	TCB_member	TCB_HERE
			RW3at
		PopST	TOS
	rjmp NEXT
	; }}}

; https://forth-standard.org/standard/core/Comma
; 
; 6.1.0150 , comma CORE
; ( x -- )
; 
; Reserve one cell of data space and store x in the cell. If the data-space pointer is aligned when , begins execution, it will remain aligned when , finishes execution. An ambiguous condition exists if the data-space pointer is not aligned prior to execution of ,.
; 
; See:
; 3.3.3 Data space, 3.3.3.1 Address alignment, A.6.1.0150 ,.
; 
; R_ationale:
; The use of , (comma) for compiling execution tokens is not portable.
; 
; See: 6.2.0945 COMPILE,. 

;
; https://forth-standard.org/standard/core/COMPILEComma
;
; 6.2.0945 COMPILE, compile-comma CORE EXT
; Interpretation:
; Interpretation semantics for this word are undefined.
; 
; Execution:
; ( xt -- )
; 
; Append the execution semantics of the definition represented by xt to the execution semantics of the current definition.
; 
; See:
; A.6.2.0945 COMPILE,.
; 
; Rationale:
; COMPILE, is the compilation equivalent of EXECUTE.
; 
; In traditional threaded-code implementations, compilation is performed by , (comma). This usage is not portable; it doesn't work for subroutine-threaded, native code, or relocatable implementations. Use of COMPILE, is portable.
; 
; In most systems it is possible to implement COMPILE, so it will generate code that is optimized to the same extent as code that is generated by the normal compilation process. However, in some implementations there are two different "tokens" corresponding to a particular definition name: the normal "execution token" that is used while interpreting or with EXECUTE, and another "compilation token" that is used while compiling. It is not always possible to obtain the compilation token from the execution token. In these implementations, COMPILE, might not generate code that is as efficient as normally compiled code.
; 
; The intention is that COMPILE, can be used as follows to write the classic interpreter/compiler loop:
; 
; ...                                                 ( c-addr )
; FIND ?DUP IF	                                    ( xt +-1 )
;    STATE @ IF	                                    ( xt +-1 )
;      0> IF EXECUTE ELSE COMPILE, THEN	  ( ??? )
;    ELSE	                                           ( xt +-1 )
;      DROP EXECUTE                                ( ??? )
;    THEN
; ELSE                                              ( c-addr )
;    ( whatever you do for an undefined word )
; THEN
; ...
; 
; Thus the interpretation semantics are left undefined, as COMPILE, will not be executed during interpretation. 
